#!/usr/bin/env python2
"""
Install the current kernel, from anywhere in the kernel source tree.
"""
import argparse
import errno
import grp
import os
import pwd
import shutil
import subprocess
import sys
import tempfile

def goto_ksrc_root():
    """
    Change directory to the root of the kernel source.  We check all
    directories above us for that root.
    """
    # these are files that should be in the root kernel directory.
    # we look for these files to makes sure we are in the source root.
    rootfiles = ["Kbuild", "Makefile", "COPYING", "README", "CREDITS", "MAINTAINERS", "REPORTING-BUGS"] 

    for f in rootfiles:
        if not os.path.exists(f):
            os.chdir("..")
            if os.getcwd() == '/':
                sys.stderr.write(
                        "ERROR: we couldn't find the root of the kernel sources in any directory above us.\n")
                sys.exit(1)

def debug_print_cur_ids():
    "Print the current uids and gids. Create a temp file and show the owner of that file."
    print("getegid() = %s, geteuid() = %s, getgid() = %s, getuid() = %s" %
            (os.getegid(), os.geteuid(), os.getgid(), os.getuid()))
    print("getresgid() = %s, getresuid() = %s" % (os.getresgid(), os.getresuid()))
    print("getlogin() = %s" % (os.getlogin()))
    fd, name = tempfile.mkstemp(dir="/tmp")
    filestat = os.fstat(fd)
    uname = pwd.getpwuid(filestat.st_uid).pw_name
    gname = grp.getgrgid(filestat.st_gid).gr_name
    print ("file stat: %s -- (%s, %s)\n" % (name, uname, gname))
    os.close(fd)
    os.remove(name)

def run_command(command=None, function=None, dropprivs=True, 
        replaceusergroup=False, captureoutput=False):
    """
    Run `command` or python function. Drop privs to user running sudo if
    dropprivs is True.  Replace strings SUDOUSER and SUDOGROUP with the user
    running sudo if replaceusergroup is True. Return string of output to stdout
	if captureoutput is True.
    """
    if command is None and function is None:
        raise Exception("Either command or function must be passed.")
    if not command is None and not function is None:
        raise Exception("Either command or function must be passed.")

    # the code below should really be using the multiprocessing module,
    # instead of the adhoc operating system interfaces.
    stdout_rpipe, stdout_wpipe = os.pipe()
    stderr_rpipe, stderr_wpipe = os.pipe()

    stdout_rpipe = os.fdopen(stdout_rpipe, 'r', 0)
    stdout_wpipe = os.fdopen(stdout_wpipe, 'w', 0)

    stderr_rpipe = os.fdopen(stderr_rpipe, 'r', 0)
    stderr_wpipe = os.fdopen(stderr_wpipe, 'w', 0)


    pid = os.fork()
    # child
    if not pid:
        stdout_rpipe.close()
        stderr_rpipe.close()

        owner_uid = os.stat(".").st_uid     # owner of the kernel sources
        original_uid = os.getuid()
        sudo_uid_gid_exist = ("SUDO_UID" in os.environ and \
                "SUDO_GID" in os.environ)

        if replaceusergroup and not sudo_uid_gid_exist:
            sys.stderr.write("ERROR: trying to replace sudo user and group "
                    "in command `%s`, but this command is not being run "
                    "with SUDO_UID and SUDO_GID enviroment variables "
                    "available.\n" % command)
            sys.exit(1)

        if replaceusergroup:
            sudo_uid = int(os.environ["SUDO_UID"])
            sudo_gid = int(os.environ["SUDO_GID"])
            sudo_user_name = pwd.getpwuid(sudo_uid).pw_name
            sudo_group_name = grp.getgrgid(sudo_gid).gr_name
            command = command.replace("SUDOUSER", sudo_user_name)
            command = command.replace("SUDOGROUP", sudo_group_name)

        if sudo_uid_gid_exist and \
                (owner_uid != original_uid) and (dropprivs == True):
            # we are being run in sudo, so we need to drop privs to run make
            sudo_uid = int(os.environ["SUDO_UID"])
            sudo_gid = int(os.environ["SUDO_GID"])
            os.setgid(sudo_gid)
            os.setuid(sudo_uid)


        # need to get this 
        cur_user_name = pwd.getpwuid(os.getuid()).pw_name

        if command:
            print("Running `%s`..." % command)

            if captureoutput:
                process = subprocess.Popen(command, shell=True, stdout=stdout_wpipe, stderr=stderr_wpipe)
            else:
                process = subprocess.Popen(command, shell=True, stdout=sys.stdout, stderr=sys.stderr)

            retcode = process.wait()
            if retcode < 0:
                sys.stderr.write("ERROR: `%s` was terminated by signal %s.\n" % 
                        (command, -retcode))
                sys.exit(1)
            elif retcode > 0:
                sys.stderr.write("ERROR: `%s` failed while "
                        "running as user %s.\n" % (command, cur_user_name))
                sys.exit(1)
            print "Finished `%s`.\n" % command
            sys.exit(0)
        else:
            sys.stdout = stdout_wpipe
            sys.stderr = stderr_wpipe
            function()
            sys.exit(0)
    # parent
    else:
        stdout_wpipe.close()
        stderr_wpipe.close()

        waitpid, exit_status = os.wait()

        stdout_output = ""
        stderr_output = ""

        if captureoutput:
            stdout_output = stdout_rpipe.read()
            stderr_output = stderr_rpipe.read()

        if exit_status != 0:
            if captureoutput:
                sys.stderr.write("Command failed with this output to stdout: %s\n" % stdout_output)
                sys.stderr.write("Command failed with this output to stderr: %s\n" % stderr_output)
            sys.exit(1)

        if captureoutput:
            return (stdout_output, stderr_output)

def mkdir_no_error(directory):
    """
    Make sure the directory exists, but don't raise an exception if it does.
    """
    try:
        os.makedirs(directory)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise e

def get_kernel_release_arch(build_dir_arg):
    """
    Return the kernel release version string and the arch that it's been built on.
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".
    """
    # get the kernel release (somethingl like 2.6.34-MY-KERNEL)
    p = subprocess.Popen(["make", "%s" % build_dir_arg, "kernelrelease"], 
            stdout=subprocess.PIPE)
    release = p.communicate()[0].strip()

    # get the current arch
    p = subprocess.Popen(["uname", "-m"], stdout=subprocess.PIPE)
    arch = p.communicate()[0].strip()

    return release, arch

def get_bzimage(build_dir_arg, builddir):
    """
    Return the built bzimage path and the path we should install the bzimage to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    bzimage = os.path.join(builddir, "arch/%s/boot/bzImage" % arch)
    bzimage_install_path = "/boot/bzImage-%s" % release
    return bzimage, bzimage_install_path

def get_config(build_dir_arg, builddir):
    """
    Return the config path and the path we should install the config to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    config = os.path.join(builddir, ".config")
    config_install_path = "/boot/config-%s" % release
    return config, config_install_path

def get_systemmap(build_dir_arg, builddir):
    """
    Return the systemmap path and the path we should install the systemmap to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    systemmap = os.path.join(builddir, "System.map")
    systemmap_install_path = "/boot/System.map-%s" % release
    return systemmap, systemmap_install_path

def install_file(file_name, install_path):
    "Install a file using shutil.copyfile() with file_name as first arg and install_path as second."
    try:
        print "Copying %s to %s" % (file_name, install_path)
        shutil.copyfile(file_name, install_path)
    except OSError, e:
        sys.stderr.write("ERROR: error when trying to copy %s to %s: %s\n" %
                (file_name, install_path, e))
        sys.exit(1)

def remote_install_file(remotehost, file_name, remote_install_path):
    """
    Install file_name on remotehost as remote_install_path.
    """
    # should we copy links?
    command = "rsync -r %s %s:%s" % (file_name, remotehost, remote_install_path)
    run_command(command)

def install_kernel_local(build_dir_arg, builddir):
    """
    Install a kernel on the local system. 
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".
    builddir is the actual build directory.  It is something like "." or "./build".
    """
    # make sure you can write to boot
    if not os.access("/boot", os.W_OK):
        sys.stderr.write("ERROR: cannot write to /boot. Need to run this script with `sudo`?\n")
        sys.exit(1)

    bzimage, bzimage_install_path = get_bzimage(build_dir_arg, builddir)
    config, config_install_path = get_config(build_dir_arg, builddir)
    systemmap, systemmap_install_path = get_systemmap(build_dir_arg, builddir)

    install_file(bzimage, bzimage_install_path)
    install_file(config, config_install_path)
    install_file(systemmap, systemmap_install_path)

def install_kernel_remote(build_dir_arg, builddir, remotehost, tempmoddir=None):
    """
    Install a kernel on the remote system.
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".

    builddir is the actual build directory.  It is something like "." or "./build".

    remotehost is the argument we pass to ssh to log into a remote host.
    It should be something like "root@127.127.127.1".

    tempmoddir is the temp directory created before running 
    `make INSTALL_MOD_PATH=/some/path modules_install`.  In this case,
    tempmoddir would be "/some/path".
    """
    bzimage, bzimage_remote_install_path = get_bzimage(build_dir_arg, builddir)
    config, config_remote_install_path = get_config(build_dir_arg, builddir)
    systemmap, systemmap_remote_install_path = get_systemmap(build_dir_arg, builddir)

    remote_install_file(remotehost, bzimage, bzimage_remote_install_path)
    remote_install_file(remotehost, config, config_remote_install_path)
    remote_install_file(remotehost, systemmap, systemmap_remote_install_path)

    if tempmoddir:
        remote_install_file(remotehost, os.path.join(tempmoddir,"lib"), "/")
        shutil.rmtree(tempmoddir)

def main():
    parser = argparse.ArgumentParser(description="Install the current kernel.")
    parser.add_argument('--make', '-m', action='store_true', 
            help="run `make` first")
    parser.add_argument('--make-install-modules', '-i', action='store_true', 
            help="run `make modules_install`")
    parser.add_argument('--ssh', '-s', action='store', metavar='REMOTE_MACHINE', 
            help="use ssh to copy kernel to REMOTE_MACHINE")

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--build-dir', '-b', action='store', 
            help="use a separate build directory, defaults to \"build/\"", 
            default="./build")
    group.add_argument('--no-build-dir', '-n', action='store_true', 
            help="don't use a separate build directory")

    args = parser.parse_args()

    if args.no_build_dir:
        builddir = "."
    else:
        builddir = args.build_dir

    build_dir_arg = "O=%s" % builddir
    temp_install_dir_arg = ""


    goto_ksrc_root()

    temp_mod_install_dir = ""

    # make the builddir if it doesn't exist, make sure there is a 
    # .config available, and finally run make
    if args.make:
        run_command(function=(lambda: mkdir_no_error(builddir)))
        if not os.path.exists(os.path.join(builddir, ".config")):
            sys.stderr.write("No kernel .config in build dir %s\n" %
                    os.path.abspath(builddir))
            sys.exit(1)
        run_command("make %s" % build_dir_arg)

    if args.make_install_modules:

        if args.ssh:
            # make a temporary directory for us to use
            func = lambda: sys.stdout.write(str(tempfile.mkdtemp()))
            #func = lambda: tempfile.mkdtemp()
            temp_mod_install_dir, _ = run_command(function=func, captureoutput=True)
            temp_install_dir_arg = "INSTALL_MOD_PATH=%s" % temp_mod_install_dir
            run_command(command="make %s %s modules_install" % (temp_install_dir_arg, build_dir_arg)) 
        else:
            run_command(command="make %s %s modules_install" % (temp_install_dir_arg, build_dir_arg), 
                    dropprivs=False)

        sudo_uid_gid_exist = ("SUDO_UID" in os.environ and \
                "SUDO_GID" in os.environ)
        if sudo_uid_gid_exist:
            run_command(command="chown -R SUDOUSER:SUDOGROUP .", dropprivs=False,
                    replaceusergroup=True)

    if args.ssh:
        if args.make_install_modules:
            install_kernel_remote(build_dir_arg, builddir, args.ssh, temp_mod_install_dir)
    else:
        install_kernel_local(build_dir_arg, builddir)




if __name__ == '__main__':
    main()

# ex: ts=4 sw=4 et filetype=python
