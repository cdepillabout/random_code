#!/usr/bin/env python2
"""
Install the current kernel, from anywhere in the kernel source tree.
"""
import argparse
import errno
import grp
import os
import pwd
import shutil
import subprocess
import sys
import tempfile

cleanup_dirs = []

def add_cleanup_dir(dirname):
    """
    Add the directory dirname to a list of files that will be cleaned up when this
    process exits, but ONLY when this process exits.
    """
    global cleanup_dirs
    cleanup_dirs.append((dirname, os.getpid()))

def cleanup():
    for dirname, pid in cleanup_dirs:
        if pid == os.getpid():
            #sys.stderr.write("Cleaning up %s from %s...\n" % (dirname, pid))
            shutil.rmtree(dirname, ignore_errors=False)

def goto_ksrc_root():
    """
    Change directory to the root of the kernel source.  We check all
    directories above us for that root.
    """
    # these are files that should be in the root kernel directory.
    # we look for these files to makes sure we are in the source root.
    rootfiles = ["Kbuild", "Makefile", "COPYING", "README", "CREDITS", "MAINTAINERS", "REPORTING-BUGS"] 

    for f in rootfiles:
        if not os.path.exists(f):
            os.chdir("..")
            if os.getcwd() == '/':
                sys.stderr.write(
                        "ERROR: we couldn't find the root of the kernel sources in any directory above us.\n")
                sys.exit(1)

def debug_print_cur_ids():
    "Print the current uids and gids. Create a temp file and show the owner of that file."
    print("getegid() = %s, geteuid() = %s, getgid() = %s, getuid() = %s" %
            (os.getegid(), os.geteuid(), os.getgid(), os.getuid()))
    print("getresgid() = %s, getresuid() = %s" % (os.getresgid(), os.getresuid()))
    print("getlogin() = %s" % (os.getlogin()))
    fd, name = tempfile.mkstemp(dir="/tmp")
    filestat = os.fstat(fd)
    uname = pwd.getpwuid(filestat.st_uid).pw_name
    gname = grp.getgrgid(filestat.st_gid).gr_name
    print ("file stat: %s -- (%s, %s)\n" % (name, uname, gname))
    os.close(fd)
    os.remove(name)

def inPATH(command):
    "Makes sure command is on PATH"
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    if not "PATH" in os.environ:
        sys.stderr.write("WARNING: PATH environment variable does not exist.\n")
        return False

    for path in os.environ["PATH"].split(os.pathsep):
        fullpath = os.path.join(path, command)
        if is_exe(fullpath):
            return True

    return False


class CommandError(Exception):
    """
    This is an error for run_command to throw if there is an error when running
    a command.
    """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def run_command(command=None, function=None, dropprivs=True, 
        replaceusergroup=False, captureoutput=False):
    """
    Run `command` or python function. Drop privs to user running sudo if
    dropprivs is True.  Replace strings SUDOUSER and SUDOGROUP with the user
    running sudo if replaceusergroup is True. Return string of output to stdout
	if captureoutput is True.
    """
    if command is None and function is None:
        raise Exception("Either command or function must be passed.")
    if not command is None and not function is None:
        raise Exception("Either command or function must be passed.")

    # the code below should really be using the multiprocessing module,
    # instead of the adhoc operating system interfaces.
    stdout_rpipe, stdout_wpipe = os.pipe()
    stderr_rpipe, stderr_wpipe = os.pipe()

    stdout_rpipe = os.fdopen(stdout_rpipe, 'r', 0)
    stdout_wpipe = os.fdopen(stdout_wpipe, 'w', 0)

    stderr_rpipe = os.fdopen(stderr_rpipe, 'r', 0)
    stderr_wpipe = os.fdopen(stderr_wpipe, 'w', 0)


    pid = os.fork()
    # child
    if not pid:
        stdout_rpipe.close()
        stderr_rpipe.close()

        owner_uid = os.stat(".").st_uid     # owner of the kernel sources
        original_uid = os.getuid()
        sudo_uid_gid_exist = ("SUDO_UID" in os.environ and \
                "SUDO_GID" in os.environ)

        if replaceusergroup and not sudo_uid_gid_exist:
            sys.stderr.write("ERROR: trying to replace sudo user and group "
                    "in command `%s`, but this command is not being run "
                    "with SUDO_UID and SUDO_GID enviroment variables "
                    "available.\n" % command)
            sys.exit(1)

        if replaceusergroup:
            sudo_uid = int(os.environ["SUDO_UID"])
            sudo_gid = int(os.environ["SUDO_GID"])
            sudo_user_name = pwd.getpwuid(sudo_uid).pw_name
            sudo_group_name = grp.getgrgid(sudo_gid).gr_name
            command = command.replace("SUDOUSER", sudo_user_name)
            command = command.replace("SUDOGROUP", sudo_group_name)

        if sudo_uid_gid_exist and \
                (owner_uid != original_uid) and (dropprivs == True):
            # we are being run in sudo, so we need to drop privs to run make
            sudo_uid = int(os.environ["SUDO_UID"])
            sudo_gid = int(os.environ["SUDO_GID"])
            os.setgid(sudo_gid)
            os.setuid(sudo_uid)



        # need to get this 
        cur_user_name = pwd.getpwuid(os.getuid()).pw_name

        # set the USER, LOGNAME, and HOME env vars correctly
        os.environ["USER"] = cur_user_name
        os.environ["LOGNAME"] = cur_user_name
        os.environ["HOME"] = pwd.getpwuid(os.getuid()).pw_dir

        if command:
            print("running `%s`" % command)

            if captureoutput:
                process = subprocess.Popen(command, shell=True, stdout=stdout_wpipe, stderr=stderr_wpipe)
            else:
                process = subprocess.Popen(command, shell=True, stdout=sys.stdout, stderr=sys.stderr)

            retcode = process.wait()
            if retcode < 0:
                sys.stderr.write("ERROR: `%s` was terminated by signal %s.\n" % 
                        (command, -retcode))
                sys.exit(1)
            elif retcode > 0:
                sys.stderr.write("ERROR: `%s` failed while "
                        "running as user %s.\n" % (command, cur_user_name))
                sys.exit(1)
            #print "Finished `%s`.\n" % command
            sys.exit(0)
        else:
            sys.stdout = stdout_wpipe
            sys.stderr = stderr_wpipe
            function()
            sys.exit(0)
    # parent
    else:
        stdout_wpipe.close()
        stderr_wpipe.close()

        waitpid, exit_status = os.wait()

        stdout_output = ""
        stderr_output = ""

        if captureoutput:
            stdout_output = stdout_rpipe.read()
            stderr_output = stderr_rpipe.read()

        if exit_status != 0:
            if captureoutput:
                if command:
                    thistype = "Command"
                else:
                    thistype = "Function"
                sys.stderr.write("%s failed with this output to stdout: %s\n" % (thistype, stdout_output))
                sys.stderr.write("%s failed with this output to stderr: %s\n" % (thistype, stderr_output))

            if command:
                raise CommandError("Command `%s` failed." % command)
            else:
                raise CommandError("Function failed.")

        if captureoutput:
            return (stdout_output, stderr_output)

def mkdir_no_error(directory):
    """
    Make sure the directory exists, but don't raise an exception if it does.
    """
    try:
        os.makedirs(directory)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise e

def get_kernel_release_arch(build_dir_arg):
    """
    Return the kernel release version string and the arch that it's been built on.
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".
    """
    # get the kernel release (somethingl like 2.6.34-MY-KERNEL)
    p = subprocess.Popen(["make", "%s" % build_dir_arg, "kernelrelease"], 
            stdout=subprocess.PIPE)
    release = p.communicate()[0].strip()

    # get the current arch
    p = subprocess.Popen(["uname", "-m"], stdout=subprocess.PIPE)
    arch = p.communicate()[0].strip()

    return release, arch

def get_bzimage(build_dir_arg, builddir):
    """
    Return the built bzimage path and the path we should install the bzimage to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    bzimage = os.path.join(builddir, "arch/%s/boot/bzImage" % arch)
    bzimage_install_path = "/boot/bzImage-%s" % release
    return bzimage, bzimage_install_path

def get_config(build_dir_arg, builddir):
    """
    Return the config path and the path we should install the config to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    config = os.path.join(builddir, ".config")
    config_install_path = "/boot/config-%s" % release
    return config, config_install_path

def get_systemmap(build_dir_arg, builddir):
    """
    Return the systemmap path and the path we should install the systemmap to.
    builddir is the build directory.  It is something like "." or "./build".
    """
    release, arch = get_kernel_release_arch(build_dir_arg)
    systemmap = os.path.join(builddir, "System.map")
    systemmap_install_path = "/boot/System.map-%s" % release
    return systemmap, systemmap_install_path

def install_file(file_name, install_path, delete=False, directory=False):
    """
    Install a file using shutil.copyfile() with file_name as first arg and
    install_path as second. If it is a directory, then use copytree.  If delete
    is True, then we try to delete the dir first only if we are dealing with
    directories.
    """
    if delete and directory:
            #print "Deleting %s" % install_path
            shutil.rmtree(install_path, ignore_errors=True)
    try:
        print "Copying %s to %s" % (file_name, install_path)
        if directory:
            shutil.copytree(file_name, install_path, symlinks=True)
        else:
            shutil.copyfile(file_name, install_path)
    except (OSError, IOError) as e:
        sys.stderr.write("ERROR: error when trying to copy %s to %s: %s\n" %
                (file_name, install_path, e))
        sys.exit(1)

def remote_install_file(remotehost, file_name, remote_install_path, copy_link=False, delete=False):
    """
    Install file_name on remotehost as remote_install_path.  If copy_link is
    true, then the real file link points to will be copied.  If it is false,
    then the symlink itself will be copied. If delete is True, then the
    --delete flag will be given to rsync.
    """
    if copy_link:
        link_flag = "-L"
    else:
        link_flag = "-l"

    if delete:
        delete_flag = "--delete"
    else:
        delete_flag = ""

    command = "rsync -r -z %s %s -q %s %s:%s" % \
            (link_flag, delete_flag, file_name, remotehost, remote_install_path)
    run_command(command)

def install_kernel_local(build_dir_arg, builddir):
    """
    Install a kernel on the local system. 
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".
    builddir is the actual build directory.  It is something like "." or "./build".
    """
    # make sure you can write to boot
    if not os.access("/boot", os.W_OK):
        sys.stderr.write("ERROR: cannot write to /boot. Need to run this script with `sudo`?\n")
        sys.exit(1)

    bzimage, bzimage_install_path = get_bzimage(build_dir_arg, builddir)
    config, config_install_path = get_config(build_dir_arg, builddir)
    systemmap, systemmap_install_path = get_systemmap(build_dir_arg, builddir)

    install_file(bzimage, bzimage_install_path)
    install_file(config, config_install_path)
    install_file(systemmap, systemmap_install_path)

def install_kernel_modules_local(build_dir_arg, tempmoddir):
    """
    Install kernel modules on the local system.  tempmoddir is the temp
    directory created before running `make INSTALL_MOD_PATH=/some/path
    modules_install`.  tempmoddir should be something like  would be
    "/some/path".
    """
    # make sure you can write to boot
    if not os.access("/lib/modules", os.W_OK):
        sys.stderr.write("ERROR: cannot write to /lib/modules. Need to run this script with `sudo`?\n")
        sys.exit(1)

    release, _ = get_kernel_release_arch(build_dir_arg)
    temp_modpath = "lib/modules/%s" % release
    real_modpath = "/lib/modules/%s" % release
    install_file(os.path.join(tempmoddir, temp_modpath), real_modpath, delete=True, directory=True)


def install_kernel_remote(build_dir_arg, builddir, remotehost):
    """
    Install a kernel image on the remote system.
    build_dir_arg is a string to pass to make to tell it where the kernel
    sources are.  It is something like "O=." or "O=./build".

    builddir is the actual build directory.  It is something like "." or "./build".

    remotehost is the argument we pass to ssh to log into a remote host.
    It should be something like "root@127.127.127.1".
    """
    bzimage, bzimage_remote_install_path = get_bzimage(build_dir_arg, builddir)
    config, config_remote_install_path = get_config(build_dir_arg, builddir)
    systemmap, systemmap_remote_install_path = get_systemmap(build_dir_arg, builddir)

    remote_install_file(remotehost, bzimage, bzimage_remote_install_path, copy_link=True)
    remote_install_file(remotehost, config, config_remote_install_path)
    remote_install_file(remotehost, systemmap, systemmap_remote_install_path)

def install_kernel_modules_remote(build_dir_arg, remotehost, tempmoddir):
    """
    Install kernel modules on the remote system.  remotehost is the argument we
    pass to ssh to log into a remote host.  It should be something like
    "root@127.127.127.1".  tempmoddir is the temp directory created before
    running `make INSTALL_MOD_PATH=/some/path modules_install`.  tempmoddir
    should be something like  would be "/some/path".
    """
    release, _ = get_kernel_release_arch(build_dir_arg)
    local_modpath = "lib/modules/%s" % release
    remote_modpath = "/lib/modules/"
    remote_install_file(remotehost, os.path.join(tempmoddir, local_modpath), 
            remote_modpath, delete=True)


def main():
    parser = argparse.ArgumentParser(description="Install the current kernel.")
    parser.add_argument('--make', '-m', action='store_true', 
            help="run `make` first")
    parser.add_argument('--make-install-modules', '-i', action='store_true', 
            help="run `make modules_install`")

    parser.add_argument('--install-kernel', '-k', action='store_true', 
            help="install kernel image to /boot")

    parser.add_argument('--ssh', '-s', action='store', metavar='REMOTE_MACHINE', 
            help="use ssh to copy kernel to REMOTE_MACHINE")

    parser.add_argument('--ccache', '-f', action='store_true',
            help="use ccache when compiling kernel")

    parser.add_argument('--ctags', '-t', action='store_true', 
            help="run `make tags`")

    make_config_group = parser.add_mutually_exclusive_group()
    make_config_group.add_argument('--make-menuconfig', '-c', action='store_true', 
            help="run `make menuconfig` first")
    make_config_group.add_argument('--make-oldconfig', '-o', action='store_true', 
            help="run `make oldconfig` first")

    build_dir_group = parser.add_mutually_exclusive_group()
    build_dir_group.add_argument('--build-dir', '-b', action='store', 
            help="use a separate build directory, defaults to \"build/\"", 
            default="./build")
    build_dir_group.add_argument('--no-build-dir', '-n', action='store_true', 
            help="don't use a separate build directory")

    args = parser.parse_args()

    if args.no_build_dir:
        builddir = "."
    else:
        builddir = args.build_dir

    build_dir_arg = "O=%s" % builddir
    temp_install_dir_arg = ""

    ccache_arg = ""
    if args.ccache:
        if inPATH("ccache"):
            ccache_arg = "CC=\"ccache gcc\""
        else:
            sys.stderr.write("WARNING: Could not find ccache on PATH.  Is it installed?\n")


    goto_ksrc_root()

    temp_mod_install_dir = ""

    # make the builddir if it doesn't exist
    if args.make or args.make_install_modules or args.make_menuconfig:
        run_command(function=(lambda: mkdir_no_error(builddir)))

    # make ctags
    if args.ctags:
        run_command("make %s tags" % build_dir_arg)

    # run menuconfig
    if args.make_menuconfig:
        run_command("make %s menuconfig" % build_dir_arg)
    if args.make_oldconfig:
        run_command("make %s oldconfig" % build_dir_arg)

    # if there is no .config in the builddir, and we are trying to run make,
    # then this is a problem
    if args.make or args.make_install_modules:
        if not os.path.exists(os.path.join(builddir, ".config")):
            sys.stderr.write("No kernel .config in build dir %s. Do you need to run make menuconfig?\n" %
                    os.path.abspath(builddir))
            sys.exit(1)

    if args.make:
        run_command("make %s %s" % (build_dir_arg, ccache_arg))

    if args.make_install_modules:
        func = lambda: sys.stdout.write(str(tempfile.mkdtemp()))
        temp_mod_install_dir, _ = run_command(function=func, captureoutput=True)
        add_cleanup_dir(temp_mod_install_dir)
        temp_install_dir_arg = "INSTALL_MOD_PATH=%s" % temp_mod_install_dir
        run_command(command="make %s %s %s modules_install" % 
                (temp_install_dir_arg, build_dir_arg, ccache_arg)) 

    if args.install_kernel or args.make_install_modules:
        if args.ssh:
            try:
                if args.install_kernel:
                    install_kernel_remote(build_dir_arg, builddir, args.ssh)
                if args.make_install_modules:
                    install_kernel_modules_remote(build_dir_arg, args.ssh, temp_mod_install_dir)
            except CommandError as e:
                sys.stderr.write("ERROR: Cannot install kernel or modules remotely: %s.\n" % e)
                sys.exit(1)
        else:
            if args.install_kernel:
                install_kernel_local(build_dir_arg, builddir)
            if args.make_install_modules:
                install_kernel_modules_local(build_dir_arg, temp_mod_install_dir)
        return

    # we are not running make or installing modules, so hopefully 
    # we are doing something else.
    if not args.ctags or args.make_menuconfig or args.make_oldconfig:
        sys.stderr.write("ERROR! Not specified to do anything.\n")





if __name__ == '__main__':
    try:
        main()
    finally:
        cleanup()

# ex: ts=4 sw=4 et filetype=python
